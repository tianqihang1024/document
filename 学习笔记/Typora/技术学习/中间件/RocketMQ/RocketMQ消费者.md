

## 基础概念

消息通过生产者发送到某一个`Topic`，如果需要订阅该`Topic`并消费里面的消息的话，就要创建对应的消费者进行消费。在介绍消费这的使用方法之前，我们先介绍消费组、消费点位、推和拉等概念

## 消费者与消费组

消息系统的重要作用之一就是削峰填谷，但比如在电商大促的场景中，如果下游消费者消费能力不足，大量的瞬时流量进入后会堆积在服务端。此时，消息的端到端延迟（从发送到被消费的时间）就会增加，对于服务端而言，一直消费历史数据也会产生冷读 [^1] 。因此需要增加消费能力来解决这个问题，最简单方法就是扩容消费者。

那么能否通过增加消费者来提高消费能力呢？首先需要了解消费组的概念，在消费者中消费组有非常重要的作用，如果多个消费者设置了相同的`Consumer Group`，我们认为这些消费者在同一个消费组内。

在`Apache RocketMQ`中有两种消费模式，分别是：

-   集群消费模式：当使用集群消费模式时，`RocketMQ`认为任意一条消息只需要被消费组内的任意一个消费者处理即可。
-   广播消费模式：当使用广播消费模式时，`RocketMQ`会将每条消息推送给消费组所有的消费者，保证消息至少被每个消费者消费一次。

集群消费模式适用于每条消息只需要被处理一次的场景，也就是说整个消费组会`Topic`收到全量的消息，而消费组内的消费者分担消费这些消息，因此可以通过扩缩消费者数量，来提升和降低消费能力，具体示例如下图所示，是最常见的消费方式。

![image-20221012212639545](C:/Users/22489/OneDrive/%E7%94%B0%E5%A5%87%E6%9D%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/TyporaImg/image-20221012212639545.png)

广播消费模式适用于每条消息需要被消费组的每个消费者处理的场景，也就是说消费组内的每个消费者都会收到订阅Topic的全量消息，因此即使扩容消费者数量也无法提升或降低消费能力，具体实例如下图所示。

![image-20221012212912174](C:/Users/22489/OneDrive/%E7%94%B0%E5%A5%87%E6%9D%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/TyporaImg/image-20221012212912174.png)



## 负载均衡

集群模式下，同一消费组内的消费者会分担收到的全量消息，这里的分配策略是怎样的？如果扩容消费者是否一定能提升消费能力？

`Apache RocketMQ`提供了多种集群模式下的分配策略，包括平均分配策略、机房优先分配策略、一致性hash分配策略，可以通过如下代码进行设置相应的负载均衡策略

```java
 consumer.setAllocateMessageQueueStrategy(new AllocateMessageQueueAveragely());
```

默认的分配策略是平均分配，这也是最常见的策略。平均分配策略下消费组内的消费者会按照类似分页的策略均摊消费。

在平均分配的算法下，可以通过消费者的数量来提高消费的并行的。比如下图中，通过增加消费者来提高消费能力。

![image-20221012213651939](C:/Users/22489/OneDrive/%E7%94%B0%E5%A5%87%E6%9D%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/TyporaImg/image-20221012213651939.png)

![image-20221012213710493](C:/Users/22489/OneDrive/%E7%94%B0%E5%A5%87%E6%9D%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/TyporaImg/image-20221012213710493.png)

但也不是一味地增加消费者就能提升消费能力的，比如下图中Topic的总队列数小于消费者的数量时，消费者将分配不到队列，即使消费者再多也无法提升消费能力。

![image-20221012213946475](C:/Users/22489/OneDrive/%E7%94%B0%E5%A5%87%E6%9D%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/TyporaImg/image-20221012213946475.png)



## 消费点位

![image-20221012214056509](C:/Users/22489/OneDrive/%E7%94%B0%E5%A5%87%E6%9D%AD/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/TyporaImg/image-20221012214056509.png)

如上图所示，在`Apache RocketMQ`中每个队列都会记录自己的最小位点，最大位点。针对与消费组，还有消费位点的概念，在集群模式下，消费位点是由客户端提交服务端保存，在广播模式下，消费位点是由客户端自己保存的。一般情况下消费位点正常更新，不会出现消息重复，但如果消费者发生奔溃或有新的消费者加入群组，就会触发重平衡，重平衡完成后，每个消费者可能会分配到新的队列，而不是之前处理的队列。为了再继续之前的工作，消费者需要读取每个队列最后一次的提交的消费位点，然后从消费位点继续拉取消息。但是在实际执行过程中，由于客户端提交给服务端的消费位点并不是实时的，所以重平衡就可能导致消息少量重复。



## 推、拉和长轮询

`MQ`的消费模式大致分为两种，一种时推`Push`，一种是拉`Pull`。

-   Push是服务端主动推送消息给客户端，优点是及时性较好，但如果客户端没有做好流控，一旦服务端推送大量消息到客户端时，就会导致客户端消息堆积甚至崩溃
-   Pull是客户端需要主动到服务端取数据，优点是客户端可以根据自己的消费能力进行消费，但拉取的频率也需要用户自己控制，拉取频繁容易造成服务端和客户端的压力，拉取间隔长又容易造成消费不及时。

`Apache RocketMQ`即提供了`Push`模式也提供了`Pull`模式



## 总结

-   消费者与消费组：消费者是处理消息的基本单元，消费组是消费者的一个属性，一个逻辑上得概念，多个消费者设置了同一个`Consumer Group`，那么可以认为这些消费者在同一个消费组内。
-   负载均衡：同一`Consumer Group`下的消费者均摊全量的消息，分配策略有平均分配策略、机房优先分配策略、一致性hash分配策略。
-   `Queue`：来自于`Topic`分片再细分的产物，是消费者消费消息的基本单元，消费者可以对应多个`Queue`，但是`Queue`无法对应多个消费者。`Queue`的数量上限决定了消费速度。
-   消费点位：`Queue`消息消费的最小位点、最大位点，每个`Queue`都在自身保存一份。集群模式下由客户端提交至服务端保存，广播模式下由客户端自己保存。消费位点在消费者下线或者新增时可能出现重平衡。
-   推、拉和长轮询：消费者获取消息的方式，Push服务端主动推送消息，Pull客户端持续请求服务端获取消息。





## 问答



### `RocketMQ`是否存在重复消费的问题

消费位点重平衡时会导致消息少量重复，



### `consumer`数量应该如何设置

`queue`和`consumer`的关系是一对一，即同一个`queue`只能被一个`consumer`消费，`consumer`数量大于`queue`数量的话会导致多出来的`consumer`闲置。而`consumer`可以监听同一`topic`下的多个`queue`，总结下来就是`consumer`的数量应该小于等于`queue`数量。



### 订阅关系不一致

订阅关系不一致（监听的`tar`不一致，监听`tar`的顺序不一致，监听的`topic`不一致）

-   解：首先明确一点，微服务的特点就是不一样的业务需要进行拆分。消费组就是一个订阅关系单元，你要订阅多个`topic`、`tar`，就不符合微服务的理念。
-   解：订阅关系不一致会出现消息丢失的问题，问题点就在于消费组对于消息的轮询上。举个栗子：`seckill`主题下有两个对列`queue-A、queue-B`，两个标识`tag1、tag2`，四条消息`message1、message2、message3、message4`。消费组这边呢？两个消费者，`A`标识了`tar1`，`B`标识了`tag2`。我们知道的，消息组会轮询获取到的消息给消费者消费。理想情况下应该这样，一个`tag1`的消息给`A`，下一个呢就是`tagb`的消息给`B`，但是理想就是理想，我们获取的消息是无序的、混乱的，标识了`tag1`的消费者不会处理`tag2`的消息。所以我们应该遵守订阅关系一致这个约束。
-   解：



### 消息堆积

- 消息堆积阈值是否合理，是否设置过小的阈值导致消息堆积。
- `consumer`数量小于`queue`导致的消息堆积，可以通过配置调整`consumer`数量解决堆积。
- consumer消费过程中存在共享资源加锁、I/O和网络资源争抢、HTTP调用未设置超时时间等原因，都会导致单条消息的消费时间很长，消息开始在服务端堆积。



















[^1]: 