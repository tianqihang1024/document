







## 索引有几种类型

1.   主键索引：也叫一级索引，以主键为基础的索引。通过主键直接找到数据行，速度最快。
2.   普通索引：也叫二级索引，以某一列数据为基础的索引。当索引无法覆盖查询结果，会使用叶子节点存储的数据主键，再跑一遍主键索引获取整行的数据。
3.   联合索引：多个二级索引的组合体，以几个列的数据为组合的索引。必须遵守最左原则，(a列，b列，c列。他们三个按照顺序组成一个联合索引。只有a列是经过排序的。打个比方，就像我的名字田奇杭，如果不遵循最左原则，查询奇，杭，奇杭其中任意一个组合，因为只有开头的姓氏经过排序，你在不知道我是田奇杭还是李奇杭，只能去全表扫描)
4.   唯一索引：二级索引里的主键索引，列一旦被打上唯一索引，列的数据在整张表里唯一不可重复。
5.   全文索引：参照中间件`ES`



## 索引失效场景

1.   对函数计算后的列进行比较
2.   对列进行加减后比较
3.   联合索引不遵守最左原则
4.   模糊查询使用`%`开头
5.   字符串列使用数字匹配
6.   对索引使用范围查询也会导致索引失效
7.   执行器优化后，感觉没必要也不会走索引



## `MySQL`查询优化中的`Using Condition、Using where `和 `Using index`概念

`Using condition`：条件过滤索引，找到所有符合索引条件的数据行，在使用`where`子句中的其他条件去过滤这些数据行（先筛选出合适的索引去搜索数据，在使用`Where`子句中的其他条件过滤数据）

`Using where`：无法使用索引或者走索引扫描，但是有些查询条件不在索引当中（`Using where`和执行器是否走全表扫描或走索引查找没关系。只是表示`MySQL`服务器在收到存储引擎返回的记录后进行后过滤`Post-filter`。不管`SQL`语句的执行计划是全表扫描（type=ALL）或非唯一索引扫描（type=ref））

`Using index`：使用索引就能确认要返回的数据，无需产生额外的回表操作（执行计划中的`Extra`列的`Using index`和`type`列的`index`含义不同，`Extra`列的`Using index`表示索引覆盖，`type`的`index`表示`Full Index Scan：完整的索引扫描`）

`Using where;Using index`：使用索引获取行数超过一条

`Null`：表示通过索引确定了数据行，但是无法覆盖要查询的列，这时候就要通过索引回表查询所需的数据。



索引查询结果量不同时`type，extra`对应的状态

- `result > 1`：`type：range	extra：Using where;Using index``
- ``result = 1`：`type：ref	extra：Using index`





## 查看最近一条死锁日志

```sql
SHOW ENGINE INNODB STATUS;
```



## Explain

range：

ref：使用非唯一索引进行数据查找

eq_ref：使用唯一索引进行数据查找

const：表中至多有一个匹配行

system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现



## MySQL事务ID的分配时机

事务开启后的第一条SQL都会分配一个事务ID。只不过读操作分配的是一个很大的默认值，而写操作分配的是正常递增的事务ID。同一个事务内的select的trx_id是



事务的操作

```mysql
-- 开启事务，在30分时执行此句
START TRANSACTION;
-- 执行查询语句，分配假事务ID，在31分时执行此句
SELECT * FROM tx_test;
-- 查看当前活跃的事务信息，在32分时执行此句
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;
-- 第一条更新语句，分配真正的事务ID，在33分时执行此句
UPDATE tx_test SET age = 99;
-- 查看当前活跃的事务信息，在34分时执行此句
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;
```



### 禁止大查询

`sql`应该遵循单表查询的原则，禁止多表联查，非索引列排序（`400w`的大表，几次复杂查询导致磁盘占用率上升`mysql`无法写入数据）

