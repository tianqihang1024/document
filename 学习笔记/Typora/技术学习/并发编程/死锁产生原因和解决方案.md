







## 什么是死锁？

死锁是指两个或以上的执行单元在执行的过程中，由于竞争资源或者通讯造成的阻塞现象，若无外力影响会一直等待下去，这时候成系统进入死锁状态（死结状态），这些永远互相等待的进程称之为死锁进程。



## 死锁的原因

- 临界资源获取顺序不统一
- 系统资源不足
- 资源分配不当



## 死锁的必要条件

- 互斥
- 请求与保持
- 不可剥夺
- 循环等待

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。



## 示例

```java
public class JConsoleTest {

    private static Integer integer = 1;
    private static String string = "1";

    public static void main(String[] args) {

        new Thread(() -> {
            // 先获取integer对象的锁
            synchronized (integer) {
                try {
                    // 睡眠5秒，用于模拟是当中存在的业务
                    TimeUnit.SECONDS.sleep(5);
                } catch (InterruptedException e) {
                }
                // 业务执行完毕后获取string对象的锁
                synchronized (string) {
                    System.out.println("string 执行成功");
                }
            }
        }).start();

        new Thread(() -> {
            // 先获取string对象的锁
            synchronized (string) {
                try {
                    // 睡眠5秒，用于模拟是当中存在的业务
                    TimeUnit.SECONDS.sleep(5);
                } catch (InterruptedException e) {
                }
                // 业务执行完毕后获取integer对象的锁
                synchronized (integer) {
                    System.out.println("integer 执行成功");
                }
            }
        }).start();
    }
}
```

上面这个示例就是因为获取锁的顺序不一致的死锁。

- 一个流程里涉及多个锁的情况下，建议使用`ReentranLock`，他的支持可中断锁、尝试获取锁，解决了死锁四个必要条件中的不可剥夺、请求与保持条件。
- 尝试减少获取下把锁前的业务时间，使其近似于同一时间抢占两把锁的效果，可以有效的减少产生死锁的风险。
- 尝试调整业务逻辑，使获取锁的顺序一致。
- 都不行话，干脆寻找两个流程的相同点，把他提成新的同步锁用于替换这两个锁。



## 其他形式的死结

线程池里只有一个线程的情况下，来了两个有依赖关系的异步任务`a`、`b`，`b`的计算依赖于`a`的结果，如果`b`先于`a`进入线程池，就会一直获取不到`a`的直接结果，因为`a`还在任务队列中阻塞，等待`b`结束后释放资源来执行自己，这是种代码规范导致的死结。

